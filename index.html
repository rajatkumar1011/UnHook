import React, { useState, useEffect, useRef } from 'react';
import { Play, Pause, Volume2, VolumeX, Maximize, Minimize, Sun, Moon, Search, Sparkles, LoaderCircle } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

// Helper function to extract YouTube Video ID
const getYouTubeId = (url) => {
    const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
    const match = url.match(regex);
    return match ? match[1] : null;
};

// --- JS-driven Animated Background Component ---
const AnimatedBackground = () => {
    const mountRef = useRef(null);
    const bubblesRef = useRef([]);
    const animationFrameId = useRef(null);

    useEffect(() => {
        const currentMount = mountRef.current;
        if (!currentMount) return;

        const numBubbles = 25;
        const bubbleElements = [];

        // Initialize bubbles
        for (let i = 0; i < numBubbles; i++) {
            const bubbleEl = document.createElement('div');
            const size = Math.random() * 10 + 4; // vw
            bubbleEl.style.width = `${size}vw`;
            bubbleEl.style.height = `${size}vw`;
            bubbleEl.style.position = 'absolute';
            bubbleEl.style.top = '0';
            bubbleEl.style.left = '0';
            bubbleEl.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
            bubbleEl.style.borderRadius = '50%';
            currentMount.appendChild(bubbleEl);
            bubbleElements.push(bubbleEl);

            bubblesRef.current[i] = {
                el: bubbleEl,
                x: Math.random() * 100, // starting x in vw
                y: Math.random() * 100 + 100, // starting y in vh (off-screen bottom)
                vx: (Math.random() - 0.5) * 0.05, // horizontal velocity
                vy: -(Math.random() * 0.05 + 0.05), // vertical velocity
            };
        }

        const animate = () => {
            bubblesRef.current.forEach(b => {
                // Update position
                b.y += b.vy;
                b.x += b.vx;

                // Add some random drift to horizontal velocity
                b.vx += (Math.random() - 0.5) * 0.005;
                // Clamp horizontal velocity
                b.vx = Math.max(-0.1, Math.min(0.1, b.vx));

                // Reset bubble if it goes off-screen
                if (b.y < -20) {
                    b.y = 110;
                    b.x = Math.random() * 100;
                    b.vx = (Math.random() - 0.5) * 0.05;
                    b.vy = -(Math.random() * 0.05 + 0.05);
                }

                // Apply transform
                b.el.style.transform = `translate(${b.x}vw, ${b.y}vh)`;
            });

            animationFrameId.current = requestAnimationFrame(animate);
        };

        animate();

        return () => {
            cancelAnimationFrame(animationFrameId.current);
            if (currentMount) {
                bubbleElements.forEach(el => {
                    if (currentMount.contains(el)) {
                        currentMount.removeChild(el);
                    }
                });
            }
            bubblesRef.current = [];
        };
    }, []);

    return <div ref={mountRef} className="fixed top-0 left-0 w-full h-full overflow-hidden z-0"></div>;
};


// --- Main App Component ---
const App = () => {
    const [theme, setTheme] = useState('dark');
    const [videoId, setVideoId] = useState(null);

    useEffect(() => {
        document.documentElement.className = theme;
        if (!document.querySelector('link[href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700&display=swap"]')) {
            const fontLink = document.createElement('link');
            fontLink.href = 'https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700&display=swap';
            fontLink.rel = 'stylesheet';
            document.head.appendChild(fontLink);
        }
    }, [theme]);

    const handleSetVideo = (url) => {
        const id = getYouTubeId(url);
        if (id) setVideoId(id); else alert('Invalid YouTube URL.');
    };

    const toggleTheme = () => setTheme(t => t === 'light' ? 'dark' : 'light');

    const transitionVariants = {
      initial: { opacity: 0, y: 30 },
      animate: { opacity: 1, y: 0 },
      exit: { opacity: 0, y: -30 },
    };

    return (
        <div style={{ fontFamily: "'Poppins', sans-serif" }} className="bg-white dark:bg-[#0d0d0f] text-black dark:text-white min-h-screen transition-colors duration-300 relative">
            {theme === 'dark' && <AnimatedBackground />}
            <div className="relative z-10">
                <AnimatePresence mode="wait">
                    {!videoId ? (
                        <motion.div
                            key="landing"
                            variants={transitionVariants}
                            initial="animate"
                            animate="animate"
                            exit="exit"
                            transition={{ duration: 0.4, ease: "easeInOut" }}
                        >
                            <LandingScreen onPlay={handleSetVideo} toggleTheme={toggleTheme} theme={theme} />
                        </motion.div>
                    ) : (
                        <motion.div
                            key="player"
                            variants={transitionVariants}
                            initial="initial"
                            animate="animate"
                            exit="exit"
                            transition={{ duration: 0.4, ease: "easeInOut" }}
                        >
                            <PlayerScreen 
                                initialVideoId={videoId} 
                                onNewUrl={handleSetVideo}
                                toggleTheme={toggleTheme} 
                                theme={theme}
                            />
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
};


// --- Landing Screen Component ---
const LandingScreen = ({ onPlay, toggleTheme, theme }) => {
    const [url, setUrl] = useState('');
    const handleSubmit = (e) => { e.preventDefault(); if (url) onPlay(url); };

    return (
        <div className="flex flex-col items-center justify-center min-h-screen p-4">
             <button onClick={toggleTheme} className="absolute top-6 right-6 text-gray-400 hover:text-black dark:hover:text-white transition-colors">
                {theme === 'dark' ? <Sun size={20} /> : <Moon size={20} />}
            </button>
            <div className="text-center w-full max-w-2xl">
                <h1 className="text-5xl md:text-7xl font-bold tracking-tight mb-1">
                     <span className="bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">
                        UnHook
                    </span>
                </h1>
                <p className="text-2xl md:text-3xl text-blue-500 dark:text-blue-400 mb-8 font-normal tracking-tight">
                    YouTube Video Player
                </p>
                <form onSubmit={handleSubmit} className="relative">
                    <Search className="absolute left-4 top-1/2 -translate-y-1/2 text-gray-400" size={20} />
                    <input type="text" value={url} onChange={(e) => setUrl(e.target.value)} placeholder="https://www.youtube.com/watch?v=..." className="w-full pl-12 pr-4 py-3 rounded-lg text-base bg-gray-100 dark:bg-[#1a1a1c] border dark:border-white/10 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all font-normal"/>
                </form>
            </div>
        </div>
    );
};


// --- Player Screen Component ---
const PlayerScreen = ({ initialVideoId, onNewUrl, toggleTheme, theme }) => {
    const [player, setPlayer] = useState(null);
    const [inputValue, setInputValue] = useState('');
    const [videoData, setVideoData] = useState({ title: '', author: '' });
    const [isPlaying, setIsPlaying] = useState(false);
    const [isMuted, setIsMuted] = useState(false);
    const [volume, setVolume] = useState(0.8);
    const [isFullscreen, setIsFullscreen] = useState(false);
    const [showControls, setShowControls] = useState(true);
    const playerContainerRef = useRef(null);
    const controlTimeoutRef = useRef(null);
    const [isGeminiLoading, setIsGeminiLoading] = useState(false);
    const [geminiResult, setGeminiResult] = useState({ title: '', content: '' });

    useEffect(() => {
        if (!window.YT) {
            const tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            document.head.appendChild(tag);
            window.onYouTubeIframeAPIReady = () => createPlayer(initialVideoId);
        } else {
            createPlayer(initialVideoId);
        }
        const onFullscreenChange = () => setIsFullscreen(!!document.fullscreenElement);
        document.addEventListener('fullscreenchange', onFullscreenChange);
        return () => { player?.destroy(); document.removeEventListener('fullscreenchange', onFullscreenChange); };
    }, [initialVideoId]);
    
    useEffect(() => { setGeminiResult({ title: '', content: '' }); }, [initialVideoId]);

    const createPlayer = (videoId) => {
        if (player) player.destroy();
        const newPlayer = new window.YT.Player('youtube-player-iframe', {
            videoId, width: '100%', height: '100%',
            playerVars: { 'autoplay': 1, 'controls': 0, 'rel': 0, 'showinfo': 0, 'modestbranding': 1, 'iv_load_policy': 3, 'fs': 0, 'disablekb': 1 },
            events: { 'onReady': onPlayerReady, 'onStateChange': onPlayerStateChange }
        });
        setPlayer(newPlayer);
    };

    const onPlayerReady = (event) => { setVideoData(event.target.getVideoData()); event.target.setVolume(volume * 100); };
    const onPlayerStateChange = (event) => setIsPlaying(event.data === window.YT.PlayerState.PLAYING);
    const handleMouseMove = () => {
        setShowControls(true);
        clearTimeout(controlTimeoutRef.current);
        controlTimeoutRef.current = setTimeout(() => { if (isPlaying) setShowControls(false); }, 3000);
    };
    const handlePlayPause = () => isPlaying ? player.pauseVideo() : player.playVideo();
    const handleMute = () => { if (isMuted) player.unMute(); else player.mute(); setIsMuted(!isMuted); };
    const handleVolumeChange = (e) => {
        const newVolume = parseFloat(e.target.value);
        setVolume(newVolume);
        player.setVolume(newVolume * 100);
        if (newVolume > 0 && isMuted) setIsMuted(false);
    };
    const handleFullscreen = () => { if (!document.fullscreenElement) playerContainerRef.current?.requestFullscreen(); else document.exitFullscreen(); };
    const handleUrlSubmit = (e) => { e.preventDefault(); onNewUrl(inputValue); };

    const generateWithGemini = async (prompt) => {
        setIsGeminiLoading(true);
        setGeminiResult({ title: '', content: '' });
        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (text) return text; else throw new Error("No content found.");
        } catch (error) {
            console.error("Gemini API error:", error);
            return `Error: Could not retrieve information. ${error.message}`;
        } finally {
            setIsGeminiLoading(false);
        }
    };

    const handleSummarize = async () => {
        const prompt = `Provide a concise, one-paragraph summary of the YouTube video titled "${videoData.title}" by the creator "${videoData.author}".`;
        const summary = await generateWithGemini(prompt);
        setGeminiResult({ title: '✨ AI Summary', content: summary });
    };

    const handleKeyMoments = async () => {
        const prompt = `Suggest 3-5 potential key moments for the video titled "${videoData.title}" by "${videoData.author}". Format them as a list with timestamps (e.g., 00:00 - Intro). Use Markdown for bolding.`;
        const moments = await generateWithGemini(prompt);
        setGeminiResult({ title: '✨ Key Moments', content: moments });
    };

    // Function to format the Gemini content, replacing ** with <strong> tags
    const formatGeminiContent = (content) => {
        const boldedContent = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        return { __html: boldedContent };
    };

    return (
        <div className="flex flex-col lg:flex-row h-screen p-4 md:p-5 gap-5">
            <div className="flex flex-col flex-grow w-full lg:w-2/3">
                <header className="w-full flex justify-between items-center mb-4 flex-shrink-0 lg:hidden">
                    <form onSubmit={handleUrlSubmit} className="relative w-full max-w-lg">
                        <Search className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400" size={18} />
                        <input type="text" value={inputValue} onChange={(e) => setInputValue(e.target.value)} placeholder="Paste another link..." className="w-full pl-10 pr-4 py-2 rounded-md text-sm bg-gray-100 dark:bg-[#1a1a1c] border-transparent focus:outline-none focus:ring-2 focus:ring-blue-500"/>
                    </form>
                    <button onClick={toggleTheme} className="ml-4 text-gray-400 hover:text-black dark:hover:text-white"><Sun size={20} /></button>
                </header>
                <div ref={playerContainerRef} className="w-full aspect-video rounded-lg shadow-2xl dark:shadow-purple-500/20 overflow-hidden relative bg-black flex-shrink-0" onMouseMove={handleMouseMove} onMouseLeave={() => isPlaying && setShowControls(false)}>
                    <div id="youtube-player-iframe" className="w-full h-full" />
                    <AnimatePresence>
                        {showControls && (
                            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} className="absolute bottom-0 left-0 right-0 p-2 sm:p-4 bg-gradient-to-t from-black/70 to-transparent">
                                <div className="flex items-center gap-2 sm:gap-4 text-white">
                                    <button onClick={handlePlayPause} className="p-2">{isPlaying ? <Pause size={24} /> : <Play size={24} />}</button>
                                    <div className="flex items-center gap-2 w-24">
                                        <button onClick={handleMute}>{isMuted || volume === 0 ? <VolumeX size={24} /> : <Volume2 size={24} />}</button>
                                        <input type="range" min="0" max="1" step="0.05" value={isMuted ? 0 : volume} onChange={handleVolumeChange} className="w-full h-1 bg-white/20 rounded-lg appearance-none cursor-pointer accent-white" />
                                    </div>
                                    <div className="flex-grow text-left ml-4 overflow-hidden">
                                        <p className="text-sm sm:text-base font-medium truncate">{videoData.title}</p>
                                        <p className="text-xs sm:text-sm text-gray-300 truncate font-normal">{videoData.author}</p>
                                    </div>
                                    <button onClick={handleFullscreen} className="p-2">{isFullscreen ? <Minimize size={24} /> : <Maximize size={24} />}</button>
                                </div>
                            </motion.div>
                        )}
                    </AnimatePresence>
                </div>
                <div className="mt-4 p-4 rounded-lg bg-gray-50 dark:bg-[#1a1a1c] flex-grow overflow-y-auto">
                    <div className="flex items-center gap-3 mb-4">
                        <button onClick={handleSummarize} disabled={isGeminiLoading} className="flex items-center gap-2 text-sm px-3 py-2 rounded-md bg-blue-500 text-white font-medium hover:bg-blue-600 disabled:bg-gray-400">
                            <Sparkles size={16}/> Summarize
                        </button>
                        <button onClick={handleKeyMoments} disabled={isGeminiLoading} className="flex items-center gap-2 text-sm px-3 py-2 rounded-md bg-gray-200 dark:bg-gray-700 font-medium hover:bg-gray-300 dark:hover:bg-gray-600 disabled:bg-gray-400">
                            <Sparkles size={16}/> Key Moments
                        </button>
                    </div>
                    <div className="min-h-[100px]">
                        {isGeminiLoading && <div className="flex items-center justify-center h-full text-gray-500"><LoaderCircle className="animate-spin mr-2" />Thinking...</div>}
                        <AnimatePresence>
                        {geminiResult.content && !isGeminiLoading && (
                            <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }}>
                                <h3 className="font-bold text-lg mb-2">{geminiResult.title}</h3>
                                <p className="text-gray-800 dark:text-gray-300 whitespace-pre-wrap leading-relaxed font-normal" dangerouslySetInnerHTML={formatGeminiContent(geminiResult.content)}></p>
                            </motion.div>
                        )}
                        </AnimatePresence>
                    </div>
                </div>
            </div>
            <div className="hidden lg:flex flex-col w-1/3">
                 <header className="w-full flex justify-between items-center mb-4 flex-shrink-0">
                    <form onSubmit={handleUrlSubmit} className="relative w-full">
                        <Search className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400" size={18} />
                        <input type="text" value={inputValue} onChange={(e) => setInputValue(e.target.value)} placeholder="Paste another link..." className="w-full pl-10 pr-4 py-2 rounded-md text-sm bg-gray-100 dark:bg-[#1a1a1c] border-transparent focus:outline-none focus:ring-2 focus:ring-blue-500"/>
                    </form>
                    <button onClick={toggleTheme} className="ml-4 text-gray-400 hover:text-black dark:hover:text-white"><Sun size={20} /></button>
                </header>
            </div>
        </div>
    );
};

export default App;
